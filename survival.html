<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã‚µãƒ³ã‚¿ã®æ‚ªå¤¢ï¼šææ€–ã®ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆé…ã‚Š</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Kosugi+Maru&display=swap');

        body {
            background-color: #1a1a1a;
            color: white;
            font-family: 'Kosugi Maru', sans-serif;
            overflow: hidden;
            /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
            touch-action: none;
            /* ãƒ¢ãƒã‚¤ãƒ«ã§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ãƒƒãƒå‹•ä½œç„¡åŠ¹åŒ– */
        }

        #gameCanvas {
            background: radial-gradient(circle at center, #2a2a3a 0%, #000000 100%);
            display: block;
            margin: 0 auto;
        }

        .horror-font {
            font-family: 'Creepster', cursive;
            letter-spacing: 2px;
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ */
        #mobile-controls {
            display: none;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls {
                display: flex;
            }
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            backdrop-filter: blur(4px);
            user-select: none;
            touch-action: none;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>

<body class="w-full h-screen flex flex-col items-center justify-center relative">

    <!-- UI Overlay -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-10">
        <!-- Top Bar -->
        <div class="flex justify-between items-start w-full max-w-4xl mx-auto">
            <div class="text-left">
                <div class="text-gray-400 text-sm">SURVIVE TIME</div>
                <div id="timerDisplay" class="text-4xl font-bold text-red-500 horror-font">60.00</div>
            </div>
            <div class="text-right">
                <div class="text-gray-400 text-sm">PRESENTS (SPACE)</div>
                <div id="presentCount" class="text-4xl font-bold text-green-400 horror-font">3</div>
            </div>
        </div>

        <!-- Center Messages -->
        <div id="messageDisplay"
            class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center w-full">
            <h1 class="text-5xl md:text-7xl text-red-600 horror-font mb-4 drop-shadow-[0_0_10px_rgba(255,0,0,0.8)]">
                SANTA'S NIGHTMARE</h1>
            <p class="text-lg md:text-xl mb-8 text-gray-300">
                å­ä¾›ãŸã¡ãŒãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’æ±‚ã‚ã¦ç£ã®ã‚ˆã†ã«è¥²ã£ã¦ãã‚‹...<br>
                ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’å›®ï¼ˆãŠã¨ã‚Šï¼‰ã«ä½¿ã£ã¦60ç§’é–“é€ƒã’åˆ‡ã‚Œï¼
            </p>
            <button id="startBtn"
                class="pointer-events-auto bg-red-700 hover:bg-red-600 text-white font-bold py-3 px-8 rounded-full shadow-lg transform transition hover:scale-105 text-xl">
                ã‚²ãƒ¼ãƒ é–‹å§‹ (SPACE)
            </button>
            <div class="mt-4 text-sm text-gray-500">
                ç§»å‹•: çŸ¢å°ã‚­ãƒ¼ / WASD <br>
                ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆè¨­ç½®: SPACE / ã‚¯ãƒªãƒƒã‚¯
            </div>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Mobile Controls -->
    <div id="mobile-controls"
        class="absolute bottom-6 left-0 right-0 px-6 justify-between items-end z-20 pointer-events-auto w-full max-w-4xl mx-auto">
        <!-- D-Pad area (handled by touch logic, visual only placeholder) -->
        <div id="joystick-area" class="w-32 h-32 bg-white/10 rounded-full relative flex items-center justify-center">
            <div id="joystick-knob" class="w-12 h-12 bg-white/40 rounded-full absolute"></div>
        </div>

        <!-- Action Button -->
        <button id="actionBtn"
            class="control-btn w-24 h-24 flex items-center justify-center bg-red-500/30 border-red-400">
            ğŸ
        </button>
    </div>

    <script>
        /**
         * ã‚²ãƒ¼ãƒ ã®è¨­å®šã¨ãƒ­ã‚¸ãƒƒã‚¯
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const timerDisplay = document.getElementById('timerDisplay');
        const presentCountDisplay = document.getElementById('presentCount');
        const messageDisplay = document.getElementById('messageDisplay');
        const startBtn = document.getElementById('startBtn');
        const actionBtn = document.getElementById('actionBtn');
        const joystickArea = document.getElementById('joystick-area');
        const joystickKnob = document.getElementById('joystick-knob');

        // ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ãƒˆ
        let gameState = 'START'; // START, PLAYING, GAMEOVER, VICTORY
        let lastTime = 0;
        let timeSurvived = 0;
        const GOAL_TIME = 60;
        let spawnTimer = 0;
        let difficultyMultiplier = 1;

        // å…¥åŠ›ç®¡ç†
        const keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false, " ": false };
        const inputVector = { x: 0, y: 0 }; // For joystick/keyboard combined

        // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ç®¡ç†
        let player;
        let enemies = [];
        let presents = [];
        let particles = [];
        let bloodParticles = [];

        // è¨­å®šå€¤
        const PLAYER_SPEED = 220;
        const ENEMY_SPEED_BASE = 160;
        const ENEMY_SPAWN_RATE_BASE = 0.8; // seconds
        const PRESENT_COOLDOWN = 1.5; // seconds to recharge 1 stock
        const MAX_PRESENTS = 3;
        const PRESENT_LURE_RADIUS = 250;
        const PRESENT_DURATION = 4.0; // seconds

        // ã‚¯ãƒ©ã‚¹å®šç¾©

        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.radius = 15;
                this.presentStock = MAX_PRESENTS;
                this.presentTimer = 0;
                this.angle = 0;
            }

            update(dt) {
                // ç§»å‹•å‡¦ç†
                let dx = 0;
                let dy = 0;

                if (keys.w || keys.ArrowUp) dy -= 1;
                if (keys.s || keys.ArrowDown) dy += 1;
                if (keys.a || keys.ArrowLeft) dx -= 1;
                if (keys.d || keys.ArrowRight) dx += 1;

                // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ã®åˆæˆ
                dx += inputVector.x;
                dy += inputVector.y;

                // æ­£è¦åŒ–
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len > 0.1) {
                    dx /= len;
                    dy /= len;
                    this.angle = Math.atan2(dy, dx);
                }

                this.x += dx * PLAYER_SPEED * dt;
                this.y += dy * PLAYER_SPEED * dt;

                // ç”»é¢ç«¯ã®åˆ¶é™
                this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

                // ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã®ã‚¹ãƒˆãƒƒã‚¯å›å¾©
                if (this.presentStock < MAX_PRESENTS) {
                    this.presentTimer += dt;
                    if (this.presentTimer >= PRESENT_COOLDOWN) {
                        this.presentStock++;
                        this.presentTimer = 0;
                        uiLayerLogic(); // FIXED: updateUI -> uiLayerLogic
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // å½±
                ctx.beginPath();
                ctx.ellipse(0, 15, 12, 6, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fill();

                // æœ¬ä½“ (ã‚µãƒ³ã‚¿ã®å¸½å­ã¨é«­ã‚’ç°¡æ˜“è¡¨ç¾)
                // ä½“
                ctx.fillStyle = '#D32F2F'; // Red
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // é«­
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(0, 5, 10, 0, Math.PI, false);
                ctx.fill();

                // å¸½å­
                ctx.fillStyle = '#D32F2F';
                ctx.beginPath();
                ctx.moveTo(-12, -5);
                ctx.lineTo(12, -5);
                ctx.lineTo(0, -25);
                ctx.fill();
                // å¸½å­ã®ãƒãƒ³ãƒãƒ³
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(0, -25, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            dropPresent() {
                if (this.presentStock > 0) {
                    presents.push(new Present(this.x, this.y));
                    this.presentStock--;
                    uiLayerLogic(); // FIXED: updateUI -> uiLayerLogic
                    createParticles(this.x, this.y, 10, '#FFD700'); // Gold sparkles
                }
            }
        }

        class Enemy {
            constructor() {
                // ç”»é¢å¤–ã‹ã‚‰ã‚¹ãƒãƒ¼ãƒ³
                const edge = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
                const buffer = 50;
                if (edge === 0) { this.x = Math.random() * canvas.width; this.y = -buffer; }
                else if (edge === 1) { this.x = canvas.width + buffer; this.y = Math.random() * canvas.height; }
                else if (edge === 2) { this.x = Math.random() * canvas.width; this.y = canvas.height + buffer; }
                else { this.x = -buffer; this.y = Math.random() * canvas.height; }

                this.width = 24;
                this.height = 20;
                this.speed = ENEMY_SPEED_BASE + (Math.random() * 50);
                this.state = 'CHASE'; // CHASE, EATING
                this.target = null;
                this.eatTimer = 0;
                this.animFrame = 0;
            }

            update(dt, player, presents) {
                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ±ºå®šãƒ­ã‚¸ãƒƒã‚¯
                let target = player;
                let minDist = Infinity;

                // æœ€ã‚‚è¿‘ã„æœ‰åŠ¹ãªãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã‚’æ¢ã™
                for (const p of presents) {
                    const d = Math.hypot(p.x - this.x, p.y - this.y);
                    if (d < PRESENT_LURE_RADIUS && d < minDist) {
                        minDist = d;
                        target = p;
                    }
                }

                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å‘ã‹ã†
                const angle = Math.atan2(target.y - this.y, target.x - this.x);

                // ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã«åˆ°é”ã—ãŸã‚‰é£Ÿã¹ã‚‹
                if (target instanceof Present) {
                    const distToPresent = Math.hypot(target.x - this.x, target.y - this.y);
                    if (distToPresent < 10) {
                        this.state = 'EATING';
                    } else {
                        this.state = 'CHASE';
                        this.x += Math.cos(angle) * this.speed * 1.5 * dt; // ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆã«ã¯èˆˆå¥®ã—ã¦é€Ÿãèµ°ã‚‹
                        this.y += Math.sin(angle) * this.speed * 1.5 * dt;
                    }
                } else {
                    this.state = 'CHASE';
                    this.x += Math.cos(angle) * this.speed * dt;
                    this.y += Math.sin(angle) * this.speed * dt;
                }

                // è¡çªåˆ¤å®š (å¯¾ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼)
                const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                if (distToPlayer < player.radius + 10) {
                    return true; // Game Over trigger
                }

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
                this.animFrame += dt * 15;
                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ã«å‘ã‘ã‚‹ã«ã¯å›è»¢ãŒå¿…è¦ã ãŒã€ç£ã£ã½ã•ã‚’å‡ºã™ãŸã‚ã‚ãˆã¦å›ºå®šã‹ã€
                // ã‚ã‚‹ã„ã¯ç§»å‹•æ–¹å‘ã«å°‘ã—å‚¾ã‘ã‚‹
                // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ãªä¸æ°—å‘³ãªã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚’æç”»

                // å››è¶³æ­©è¡Œã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆä¸Šä¸‹ã«è·³ã­ã‚‹ï¼‰
                const bounce = Math.sin(this.animFrame) * 3;

                // æœ¬ä½“ï¼ˆé»’ã„å¡Šï¼‰
                ctx.fillStyle = '#111';
                if (this.state === 'EATING') ctx.fillStyle = '#553333'; // é£Ÿã¹ã¦ã„ã‚‹ã¨ãã¯å°‘ã—èµ¤ã‚‰ã‚€

                ctx.beginPath();
                // æ­ªã‚“ã æ¥•å††
                ctx.ellipse(0, bounce, 12, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // ç›®ï¼ˆå…‰ã‚‹ï¼‰
                ctx.fillStyle = '#FFFF00'; // Yellow eyes
                ctx.beginPath();
                ctx.arc(-4, bounce - 2, 2, 0, Math.PI * 2);
                ctx.arc(4, bounce - 2, 2, 0, Math.PI * 2);
                ctx.fill();

                // æ‰‹è¶³ï¼ˆã‚«ã‚µã‚«ã‚µå‹•ãï¼‰
                ctx.strokeStyle = '#111';
                ctx.lineWidth = 2;
                const legOffset = Math.cos(this.animFrame) * 5;

                // å·¦è¶³
                ctx.beginPath(); ctx.moveTo(-5, 0); ctx.lineTo(-15 + legOffset, 10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-8, 0); ctx.lineTo(-18 - legOffset, 5); ctx.stroke();
                // å³è¶³
                ctx.beginPath(); ctx.moveTo(5, 0); ctx.lineTo(15 - legOffset, 10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(8, 0); ctx.lineTo(18 + legOffset, 5); ctx.stroke();

                ctx.restore();
            }
        }

        class Present {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = PRESENT_DURATION;
                this.scale = 0; // å‡ºç¾ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
            }

            update(dt) {
                this.life -= dt;
                if (this.scale < 1) this.scale += dt * 5;
                if (this.scale > 1) this.scale = 1;
                return this.life <= 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);

                // åŠ¹æœç¯„å›²ã®è¡¨ç¤º (è–„ã„å††)
                if (this.life > 0.5) {
                    ctx.beginPath();
                    ctx.arc(0, 0, PRESENT_LURE_RADIUS * (this.life / PRESENT_DURATION), 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 * (this.life / PRESENT_DURATION)})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // ç®±
                ctx.fillStyle = '#2E7D32'; // Green box
                ctx.fillRect(-12, -12, 24, 24);

                // ãƒªãƒœãƒ³
                ctx.fillStyle = '#C62828'; // Red ribbon
                ctx.fillRect(-4, -12, 8, 24);
                ctx.fillRect(-12, -4, 24, 8);

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color, speed) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.05 + 0.02;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1.0;
            }
        }

        class Snow {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 1;
                this.speed = Math.random() * 50 + 20;
            }
            update(dt) {
                this.y += this.speed * dt;
                if (this.y > canvas.height) {
                    this.y = -10;
                    this.x = Math.random() * canvas.width;
                }
            }
            draw() {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // åˆæœŸåŒ–é–¢æ•°
        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // é›ªã®ç”Ÿæˆ
            particles = [];
            for (let i = 0; i < 100; i++) {
                particles.push(new Snow());
            }
        }

        function startGame() {
            player = new Player();
            enemies = [];
            presents = [];
            bloodParticles = [];
            timeSurvived = GOAL_TIME;
            spawnTimer = 0;
            gameState = 'PLAYING';
            lastTime = performance.now();

            // UIæ›´æ–°
            messageDisplay.style.display = 'none';
            uiLayerLogic();
            requestAnimationFrame(gameLoop);
        }

        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                bloodParticles.push(new Particle(x, y, color, Math.random() * 5));
            }
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            createParticles(player.x, player.y, 50, '#FF0000');
            messageDisplay.innerHTML = `
                <h1 class="text-6xl text-red-600 horror-font mb-4">CAUGHT!</h1>
                <p class="text-xl text-gray-300 mb-8">å­ä¾›ãŸã¡ã«æ•ã¾ã£ã¦ã—ã¾ã£ãŸ...</p>
                <button onclick="startGame()" class="pointer-events-auto bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-full">ã‚‚ã†ä¸€åº¦ (SPACE)</button>
            `;
            messageDisplay.style.display = 'block';
        }

        function victory() {
            gameState = 'VICTORY';
            messageDisplay.innerHTML = `
                <h1 class="text-6xl text-green-500 horror-font mb-4">SURVIVED!</h1>
                <p class="text-xl text-gray-300 mb-8">ç„¡äº‹ã«æœã‚’è¿ãˆãŸï¼</p>
                <button onclick="startGame()" class="pointer-events-auto bg-green-700 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full">ã‚‚ã†ä¸€åº¦ (SPACE)</button>
            `;
            messageDisplay.style.display = 'block';
        }

        function uiLayerLogic() {
            if (gameState === 'PLAYING') {
                timerDisplay.textContent = timeSurvived.toFixed(2);
                presentCountDisplay.textContent = player.presentStock;

                // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³è¡¨ç¤ºï¼ˆè‰²ãŒæš—ããªã‚‹ï¼‰
                if (player.presentStock === 0) {
                    presentCountDisplay.classList.remove('text-green-400');
                    presentCountDisplay.classList.add('text-red-500');
                } else {
                    presentCountDisplay.classList.add('text-green-400');
                    presentCountDisplay.classList.remove('text-red-500');
                }
            }
        }

        // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
        function gameLoop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // é›ªã®æç”»ï¼ˆèƒŒæ™¯ï¼‰
            particles.forEach(p => {
                if (p instanceof Snow) {
                    p.update(dt);
                    p.draw();
                }
            });

            if (gameState === 'PLAYING') {
                // ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
                timeSurvived -= dt;
                if (timeSurvived <= 0) {
                    timeSurvived = 0;
                    victory();
                }

                // é›£æ˜“åº¦ä¸Šæ˜‡ï¼ˆæ™‚é–“çµŒéã§æ•µã®ã‚¹ãƒãƒ¼ãƒ³ç‡ã‚¢ãƒƒãƒ—ï¼‰
                const progress = 1 - (timeSurvived / GOAL_TIME);
                difficultyMultiplier = 1 + progress * 2;

                // æ•µã‚¹ãƒãƒ¼ãƒ³
                spawnTimer += dt;
                const currentSpawnRate = Math.max(0.1, ENEMY_SPAWN_RATE_BASE / difficultyMultiplier);

                if (spawnTimer > currentSpawnRate) {
                    enemies.push(new Enemy());
                    spawnTimer = 0;
                }

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°
                player.update(dt);
                player.draw();

                // ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆæ›´æ–°
                for (let i = presents.length - 1; i >= 0; i--) {
                    if (presents[i].update(dt)) {
                        presents.splice(i, 1);
                    } else {
                        presents[i].draw();
                    }
                }

                // æ•µæ›´æ–°
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (enemies[i].update(dt, player, presents)) {
                        gameOver();
                    }
                    enemies[i].draw();
                }

                uiLayerLogic();
            } else {
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼/ã‚¯ãƒªã‚¢æ™‚ã®èƒŒæ™¯æç”»ç¶™ç¶šï¼ˆåœæ­¢çŠ¶æ…‹ï¼‰
                presents.forEach(p => p.draw());
                enemies.forEach(e => e.draw());
                if (player) player.draw();
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆè¡€ã—ã¶ããªã©ï¼‰
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                bloodParticles[i].update();
                bloodParticles[i].draw(ctx);
                if (bloodParticles[i].life <= 0) {
                    bloodParticles.splice(i, 1);
                }
            }

            if (gameState === 'PLAYING' || bloodParticles.length > 0) {
                requestAnimationFrame(gameLoop);
            }
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        window.addEventListener('resize', init);

        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key) || e.key === " ") {
                keys[e.key] = true;
            }
            if (e.key === " " && gameState === 'PLAYING') {
                player.dropPresent();
            }
            if (e.key === " " && (gameState === 'START' || gameState === 'GAMEOVER' || gameState === 'VICTORY')) {
                // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã¨åŒã˜æŒ™å‹•ã«ã™ã‚‹ãŸã‚ã€å˜ç´”ã«startGameã‚’å‘¼ã¶å‰ã«å°‘ã—å¾…ã¤ãªã©ã®å‡¦ç†ã¯ã„ã‚‰ãªã„ãŒã€
                // å³åº§ã«é–‹å§‹ã™ã‚‹ã¨èª¤çˆ†ã™ã‚‹ã®ã§é˜²ããŸã„ãªã‚‰ã“ã“ã«ãƒ•ãƒ©ã‚°ã‚’å…¥ã‚Œã‚‹ã€‚ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€‚
                if (document.getElementById('messageDisplay').style.display !== 'none') {
                    startGame();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key) || e.key === " ") {
                keys[e.key] = false;
            }
        });

        startBtn.addEventListener('click', startGame);
        actionBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'PLAYING') player.dropPresent();
        });
        actionBtn.addEventListener('click', (e) => {
            if (gameState === 'PLAYING') player.dropPresent();
        });

        // ã‚¿ãƒƒãƒæ“ä½œï¼ˆã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼‰
        let touchId = null;
        const joystickRadius = 64; // joystick-area w/2

        joystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            touchId = touch.identifier;
            updateJoystick(touch.clientX, touch.clientY);
        });

        joystickArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === touchId) {
                    updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    break;
                }
            }
        });

        joystickArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            resetJoystick();
        });

        function updateJoystick(clientX, clientY) {
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let dx = clientX - centerX;
            let dy = clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å¯å‹•ç¯„å›²åˆ¶é™
            const maxDist = rect.width / 2 - 24; // knob size half

            let normalizedX = dx;
            let normalizedY = dy;

            if (distance > maxDist) {
                normalizedX = (dx / distance) * maxDist;
                normalizedY = (dy / distance) * maxDist;
            }

            joystickKnob.style.transform = `translate(${normalizedX}px, ${normalizedY}px)`;

            // å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«æ›´æ–° (-1 to 1)
            inputVector.x = dx / maxDist;
            inputVector.y = dy / maxDist;

            // ã‚¯ãƒ©ãƒ³ãƒ—
            if (distance > maxDist) {
                inputVector.x = dx / distance;
                inputVector.y = dy / distance;
            }
        }

        function resetJoystick() {
            touchId = null;
            joystickKnob.style.transform = `translate(0px, 0px)`;
            inputVector.x = 0;
            inputVector.y = 0;
        }

        // ã‚¹ã‚¿ãƒ¼ãƒˆ
        init();

    </script>
</body>

</html>